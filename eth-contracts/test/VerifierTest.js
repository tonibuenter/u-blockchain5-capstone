const expect = require('chai').expect;
const truffleAssert = require('truffle-assertions');
const { _proof_uint } = require('./utils');
const contractAbi = artifacts.require('Verifier');
const proofFromFile = require('../../zokrates/code/proof.json');
let _proof;
contract('Verifier', (accounts) => {
  before(async () => {
    contract = await contractAbi.new({ from: accounts[0] });
    _proof = _proof_uint(proofFromFile);
  });

  it('Test 01 verify proof and event', async () => {
    let tx = await contract.verifyTx(
      _proof.proof.A,
      _proof.proof.A_p,
      _proof.proof.B,
      _proof.proof.B_p,
      _proof.proof.C,
      _proof.proof.C_p,
      _proof.proof.H,
      _proof.proof.K,
      _proof.input
    );

    truffleAssert.eventEmitted(tx, 'Verified', (ev) => {
      return expect(ev.s).to.deep.equal('Transaction successfully verified.');
    });
  });

  it('Test 02 verify false', async () => {
    let tx = await contract.verifyTx(
      _proof.proof.A,
      _proof.proof.A_p,
      _proof.proof.B,
      _proof.proof.B_p,
      _proof.proof.C_p, //should be proof.C insteaf of C_p
      _proof.proof.C_p,
      _proof.proof.H,
      _proof.proof.K,
      _proof.input
    );

    truffleAssert.eventNotEmitted(tx, 'Verified');
  });

  it('Test 03 :: false proof (16,1)', async () => {
    let tx = await contract.verifyTx(
      _proof.proof.A,
      _proof.proof.A_p,
      _proof.proof.B,
      _proof.proof.B_p,
      _proof.proof.C,
      _proof.proof.C_p,
      _proof.proof.H,
      _proof.proof.K,
      [16, 1]
    );
    truffleAssert.eventNotEmitted(tx, 'Verified');
  });
});

// const _proof_uint = () => {
//   return {
//     proof: {
//       A: [BN(proofFromFile.proof.A[0]).toString(), BN(proofFromFile.proof.A[1]).toString()],
//       A_p: [BN(proofFromFile.proof.A_p[0]).toString(), BN(proofFromFile.proof.A_p[1]).toString()],
//       B: [
//         [BN(proofFromFile.proof.B[0][0]).toString(), BN(proofFromFile.proof.B[0][1]).toString()],
//         [BN(proofFromFile.proof.B[1][0]).toString(), BN(proofFromFile.proof.B[1][1]).toString()]
//       ],
//       B_p: [BN(proofFromFile.proof.B_p[0]).toString(), BN(proofFromFile.proof.B_p[1]).toString()],
//       C: [BN(proofFromFile.proof.C[0]).toString(), BN(proofFromFile.proof.C[1]).toString()],
//       C_p: [BN(proofFromFile.proof.C_p[0]).toString(), BN(proofFromFile.proof.C_p[1]).toString()],
//       H: [BN(proofFromFile.proof.H[0]).toString(), BN(proofFromFile.proof.H[1]).toString()],
//       K: [BN(proofFromFile.proof.K[0]).toString(), BN(proofFromFile.proof.K[1]).toString()]
//     },
//     input: proofFromFile.input
//   };
// };
// define a variable to import the <Verifier> or <renamedVerifier> solidity contract generated by Zokrates

// Test verification with correct proof
// - use the contents from proof.json generated from zokrates steps

// Test verification with incorrect proof
